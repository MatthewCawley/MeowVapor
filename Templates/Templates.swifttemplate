import HTTP
import Vapor
import Foundation
import MeowVapor

<%
// Selects all classes and structs that are either based on a model or embeddable protocol
let classes = (types.classes.based["Model"] ?? []) + (types.classes.based["Embeddable"] ?? [])
let structs = (types.structs.based["Model"] ?? []) + (types.structs.based["Embeddable"] ?? [])
let serializables = classes + structs
%>

<%
  // Keeps track of all used types so they don't occur twice, workaround for a Sourcery bug
  var usedNames = [String]()
%>

<%
  // Selects all enums that are embeddable and generates a ype safe query for them, as well as it's conversion to a BSONValue
  for type in types.enums where type.based["Embeddable"] != nil && type.rawTypeName != nil {
%>
  extension <%= type.name %> : ConcreteSingleValueSerializable {
    <%
      // Creates this type from a BSON ValueConvertible
    %>
    init(value: ValueConvertible) throws {
      let value: <%= type.rawTypeName! %> = try Meow.Helpers.requireValue(value.makeBSONPrimitive() as? <%= type.rawTypeName! %>, keyForError: "")
      let me: <%= type.name %> = try Meow.Helpers.requireValue(<%= type.name %>(rawValue: value), keyForError: "")

      self = me
    }

    <%
      // Serializes this enum case to a BSON type
    %>
    func meowSerialize() -> ValueConvertible {
      return self.rawValue
    }

    <%
      // Generates a type safe query object for this enum type
    %>
    struct VirtualInstance {
      <%
        // Compares this enum's VirtualInstance type with an actual enum case and generates a Query
      %>
      static func ==(lhs: VirtualInstance, rhs: <%= type.name %>) -> Query {
        return lhs.keyPrefix == rhs.meowSerialize()
      }

      var keyPrefix: String

      init(keyPrefix: String = "") {
        self.keyPrefix = keyPrefix
      }
    }
  }
<% } %>

<%
  // Loops over all serializable objects and creates an extension to ConcreteSerializable for each one
  // ConcreteSerializable allows serializing to and from a BSON Document with this type
  for type in serializables {
%>
extension <%= type.name %> : ConcreteSerializable {
  func meowSerialize() -> Document {
    <%
      // Add the _id for models
      if type.based["Model"] != nil {
    %>
      var doc: Document = ["_id": self.id]
    <% } else { %>
    var doc = Document()
    <% } %>

    <%
      // If this is a DynamicSerializable object, apply the additionalFields fields that don't reside inside the schema
      if type.based["DynamicSerializable"] != nil {
    %>
      doc += self.additionalFields
    <% } %>

    <%
      // Loops over all variables in this Model/Embeddable and serializes them to the output document
      for variable in type.allVariables {
        // If this is an array
        if variable.typeName.unwrappedTypeName.hasPrefix("[") && variable.typeName.unwrappedTypeName.hasSuffix("]") {

          // If it's an array of ValueConvertible types
          if variable.typeName.unwrappedTypeName == "[String]"
           || variable.typeName.unwrappedTypeName == "[Data]"
           || variable.typeName.unwrappedTypeName == "[Date]"
           || variable.typeName.unwrappedTypeName == "[Bool]"
           || variable.name != "id" && variable.typeName.unwrappedTypeName == "[ObjectId]"
           || variable.typeName.unwrappedTypeName == "[Double]"
           || variable.typeName.unwrappedTypeName == "[Int32]"
           || variable.typeName.unwrappedTypeName == "[Int64]"
           || variable.typeName.unwrappedTypeName == "[Int]" {
             %>
          doc["<%= variable.name %>"] = self.<%= variable.name %>
        <%
        // If it's an array of references
          } else if variable.typeName.name.hasPrefix("[Reference") { %>
          doc["<%= variable.name %>"] = self.<%= variable.name %><% if variable.typeName.isOptional { %>?<% } %>.map { $0.id }
       <% }
        // TODO: Support [Embeddable]?

        // If this is not an array
        } else {
          // If the type is a BSON primitive type
          if variable.typeName.unwrappedTypeName == "String"
           || variable.typeName.unwrappedTypeName == "Data"
           || variable.typeName.unwrappedTypeName == "Date"
           || variable.typeName.unwrappedTypeName == "Bool"
           || variable.name != "id" && variable.typeName.unwrappedTypeName == "ObjectId"
           || variable.typeName.unwrappedTypeName == "Double"
           || variable.typeName.unwrappedTypeName == "Int32"
           || variable.typeName.unwrappedTypeName == "Int64"
           || variable.typeName.unwrappedTypeName == "Int" { %>
          doc["<%= variable.name %>"] = self.<%= variable.name %>
        <%
          // If this is a single reference
          } else if variable.typeName.name.hasPrefix("Reference") {
        %>
          doc["<%= variable.name %>"] = self.<%= variable.name %><% if variable.typeName.isOptional { %>?<% } %>.id
        <% } else if variable.type?.based["Embeddable"] != nil { %>
          doc[raw: "<%= variable.name %>"] = self.<%= variable.name %><% if variable.typeName.isOptional { %>?<% } %>.meowSerialize()
        <%
        }
      }
    } %>

    return doc
  }

  <%
    // Creates a new instance of this model/embeddable from a Document
  %>
  convenience init(fromDocument source: Document) throws {
    var source = source
      // Extract all properties
      <% usedNames = [] %>
      <% for variable in type.variables where !usedNames.contains(variable.name) { %>
        <% usedNames.append(variable.name) %>

        <% if variable.typeName.unwrappedTypeName.hasPrefix("[") && variable.typeName.unwrappedTypeName.hasSuffix("]") { %>
          <% if variable.typeName.unwrappedTypeName == "[String]"
             || variable.typeName.unwrappedTypeName == "[Data]"
             || variable.typeName.unwrappedTypeName == "[Date]"
             || variable.typeName.unwrappedTypeName == "[Bool]"
             || variable.name != "id" && variable.typeName.unwrappedTypeName == "[ObjectId]"
             || variable.typeName.unwrappedTypeName == "[Double]"
             || variable.typeName.unwrappedTypeName == "[Int32]"
             || variable.typeName.unwrappedTypeName == "[Int64]"
             || variable.typeName.unwrappedTypeName == "[Int]" { %>
             // The property is a BSON type, so we can just extract it from the document:
             <% if variable.typeName.isOptional { %>
                  let <%=variable.name%>Value: <%=variable.typeName%> = source.removeValue(forKey: "<%=variable.name%>") as? <%=variable.typeName.unwrappedTypeName%>
             <% } else { %>
                  let <%=variable.name%>Value: <%=variable.typeName%> = try Meow.Helpers.requireValue(source.removeValue(forKey: "<%=variable.name%>") as? <%=variable.typeName%>, keyForError: "<%=variable.name%>")
             <% } %>
          <% } else if variable.typeName.name.hasPrefix("[Reference") { %>
            // o the noes it is a reference
            let <%=variable.name%>Ids = try Meow.Helpers.requireValue(source.removeValue(forKey: "<%=variable.name%>") as? Document, keyForError: "<%=variable.name%>").arrayValue
            let <%=variable.name%>Value: <%=variable.typeName%>

            <% if variable.typeName.isOptional { %>
               if let <%=variable.name%>Ids = <%=variable.name%>Ids {
                   <%=variable.name%>Value = try <%=variable.name%>Ids.map { try Meow.Helpers.requireValue($0 as? ObjectId, keyForError: "<%=variable.name%>") }
               } else {
                   <%=variable.name%>Value = nil
               }
            <% } else { %>
               <%=variable.name%>Value = try <%=variable.name%>Ids.map {
                  Reference(restoring: try Meow.Helpers.requireValue($0 as? ObjectId, keyForError: "<%=variable.name%>"))
                }
            <% } %>
          <% } %>
        <% } else { %>
          <% if variable.typeName.unwrappedTypeName == "String"
             || variable.typeName.unwrappedTypeName == "Data"
             || variable.typeName.unwrappedTypeName == "Date"
             || variable.typeName.unwrappedTypeName == "Bool"
             || variable.name != "id" && variable.typeName.unwrappedTypeName == "ObjectId"
             || variable.typeName.unwrappedTypeName == "Double"
             || variable.typeName.unwrappedTypeName == "Int32"
             || variable.typeName.unwrappedTypeName == "Int64"
             || variable.typeName.unwrappedTypeName == "Int" { %>
             // The property is a BSON type, so we can just extract it from the document:
             <% if variable.typeName.isOptional { %>
                  let <%=variable.name%>Value: <%=variable.typeName%> = source.removeValue(forKey: "<%=variable.name%>") as? <%=variable.typeName.unwrappedTypeName%>
             <% } else { %>
                  let <%=variable.name%>Value: <%=variable.typeName%> = try Meow.Helpers.requireValue(source.removeValue(forKey: "<%=variable.name%>") as? <%=variable.typeName%>, keyForError: "<%=variable.name%>")
             <% } %>
          <% } else if variable.typeName.name.hasPrefix("Reference") { %>
             // o the noes it is a reference
             let <%=variable.name%>Id: ObjectId? = source.removeValue(forKey: "<%=variable.name%>") as? ObjectId
             let <%=variable.name%>Value: <%=variable.typeName%>

             <% if variable.typeName.isOptional { %>
                if let <%=variable.name%>Id = <%=variable.name%>Id {
                    <%=variable.name%>Value = Reference(restoring: <%=variable.name%>Id)
                } else {
                    <%=variable.name%>Value = nil
                }
             <% } else { %>
                <%=variable.name%>Value = Reference(restoring: try Meow.Helpers.requireValue(<%=variable.name%>Id, keyForError: "<%=variable.name%>"))
             <% } %>
        <% } else if variable.type?.based["Embeddable"] != nil { %>
          <% if variable.typeName.isOptional { %>
              let <%=variable.name%>Value: <%=variable.typeName%>
              <% if variable.type?.kind == "enum" { %>
                  if let sourceVal = source.removeValue(forKey: "<%=variable.name%>") {
                    <%=variable.name%>Value = try <%=variable.typeName.unwrappedTypeName%>(value: sourceVal)
                  } else {
                    <%=variable.name%>Value = nil
                  }
                <% } else { %>

                if let <%=variable.name%>Document: Document = source.removeValue(forKey: "<%=variable.name%>") as? Document {
                  <%=variable.name%>Value = try <%=variable.typeName.unwrappedTypeName%>(fromDocument: <%=variable.name%>Document)
                } else {
                  <%=variable.name%>Value = nil
                }
              <% } %>
          <% } else { %>
              <% if variable.type?.kind == "enum" { %>
                let <%=variable.typeName%>Val = try Meow.Helpers.requireValue(source.removeValue(forKey: "<%=variable.name%>"), keyForError: "<%=variable.name%>")
                let <%=variable.name%>Value: <%=variable.typeName%> = try <%=variable.typeName%>(value: <%=variable.typeName%>Val)
              <% } else { %>
              let <%=variable.name%>Document: Document = try Meow.Helpers.requireValue(source.removeValue(forKey: "<%=variable.name%>") as? Document, keyForError: "<%=variable.name%>")
                let <%=variable.name%>Value: <%=variable.typeName%> = try <%=variable.typeName%>(fromDocument: <%=variable.name%>Document)
              <% } %>
          <% } %>
        <% } else if variable.name == "id" { %>
            let idValue: ObjectId = try Meow.Helpers.requireValue(source.removeValue(forKey: "_id") as? ObjectId, keyForError: "id")
        <% } %>
      <% } %>
     <% } %>

      // Uses the first existing initializer
      // TODO: Support multiple/more complex initializers
      try self.init(
        <% let parameters = type.initializers.first?.parameters ?? [] %>
        <% for (index, parameter) in parameters.enumerated() { %>
          <%= parameter.argumentLabel %>: <%= parameter.name%>Value
          <% if parameters.count != index+1 { %>
          ,
          <% } %>
        <% } %>
      )

      // Sets the other variables
      <% usedNames = [] %>
      <% for variable in type.variables where !usedNames.contains(variable.name) { %>
        <% usedNames.append(variable.name) %>
        <% if type.based["DynamicSerializable"] != nil && variable.name == "additionalFields" { %>
          self.additionalFields = source
        <% } else { %>
          self.<%=variable.name%> = <%=variable.name%>Value
        <% } %>
      <% } %>
  }

  <%
    // The VirtualInstance of this type. Part of the type safe query language
  %>
  struct VirtualInstance {
    var keyPrefix: String

    <% usedNames = [] %>
    <% for variable in type.variables where !usedNames.contains(variable.name) { %>
      <% usedNames.append(variable.name) %>
      // <%=variable.name%>: <%=variable.typeName%>
      <% if variable.typeName.unwrappedTypeName == "String"
         || variable.typeName.unwrappedTypeName == "ObjectId"
         || variable.typeName.unwrappedTypeName == "Date"
         || variable.typeName.unwrappedTypeName == "Data"
         || variable.typeName.unwrappedTypeName == "Bool" { %>
        var <%= variable.name %>: Virtual<%=variable.unwrappedTypeName%> { return Virtual<%=variable.unwrappedTypeName%>(name: keyPrefix + "<%=variable.name%>") }
      <% } else if variable.typeName.unwrappedTypeName == "[String]"
         || variable.typeName.unwrappedTypeName == "[ObjectId]"
         || variable.typeName.unwrappedTypeName == "[Date]"
         || variable.typeName.unwrappedTypeName == "[Data]"
         || variable.typeName.unwrappedTypeName == "[Bool]" { %>
        var <%= variable.name %>: VirtualArray<Virtual<%=variable.unwrappedTypeName%>> { return VirtualArray<Virtual<%=variable.unwrappedTypeName%>>(name: keyPrefix + "<%=variable.name%>") }
      <% } else if variable.typeName.unwrappedTypeName == "Int"
         || variable.typeName.unwrappedTypeName == "Int32"
         || variable.typeName.unwrappedTypeName == "Int64"
         || variable.typeName.unwrappedTypeName == "Double" { %>
        var <%= variable.name %>: VirtualNumber { return VirtualNumber(name: keyPrefix + "<%=variable.name%>") }
      <% } else if variable.typeName.unwrappedTypeName == "[Int]"
         || variable.typeName.unwrappedTypeName == "[Int32]"
         || variable.typeName.unwrappedTypeName == "[Int64]"
         || variable.typeName.unwrappedTypeName == "[Double]" { %>
        var <%= variable.name %>: VirtualArray<VirtualNumber> { return VirtualArray<VirtualNumber>(name: keyPrefix + "<%=variable.name%>") }
      <% } else if variable.typeName.name.hasPrefix("Reference") { %>
        var <%= variable.name %>: VirtualReference<<%=variable.typeName.unwrappedTypeName%>.Model, <%=variable.typeName.unwrappedTypeName%>.DeleteRule> { return VirtualReference(name: keyPrefix + "<%=variable.name%>") }
      <% } else if variable.typeName.name.hasPrefix("[Reference") { %>
        var <%= variable.name %>: VirtualReferenceArray<<%=variable.typeName.unwrappedTypeName.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "") %>.Model, <%=variable.typeName.unwrappedTypeName.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")%>.DeleteRule> { return VirtualReferenceArray<<%=variable.typeName.unwrappedTypeName.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "") %>.Model, <%=variable.typeName.unwrappedTypeName.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")%>.DeleteRule>(name: keyPrefix + "<%=variable.name%>") }
      <% } else if variable.type?.based["Embeddable"] != nil { %>
        var <%=variable.name%>: <%=variable.typeName.unwrappedTypeName%>.VirtualInstance { return <%=variable.typeName.unwrappedTypeName%>.VirtualInstance(keyPrefix: "<%=variable.name%>.") }
      <% } else { %>
        // <%=variable%>
      <% } %>
    <% } %>

    init(keyPrefix: String = "") {
      self.keyPrefix = keyPrefix
    }
  }

  <%
    // Keeps track of all references in this model
    // Used for applying delete rules on references
  %>
  var meowReferencesWithValue: [(key: String, destinationType: ConcreteModel.Type, deleteRule: DeleteRule.Type, id: ObjectId)] {
      var result = [(key: String, destinationType: ConcreteModel.Type, deleteRule: DeleteRule.Type, id: ObjectId)]()
      _ = result.popLast() // to silence the warning of not mutating above variable in the case of a type with no references

      <% for variable in type.variables { %>
        <% if variable.typeName.name.hasPrefix("Reference") { %>
          <% if variable.isOptional { %>
            if let <%=variable.name%>Value = self.<%=variable.name%> {
          <% } else { %>
            let <%=variable.name%>Value = self.<%=variable.name%>
          <% } %>
          result.append(("<%=variable.name%>", <%=variable.name%>Value.destinationType, <%=variable.name%>Value.deleteRule, <%=variable.name%>Value.id))
          <% if variable.isOptional { %>
            }
          <% } %>
        <% } %>
      <% } %>

      return result
  }
}
<% } %>


<%
  // For each model, generate a type safe query language and helpers for Vapor
  for type in types.based["Model"] ?? [] {
%>
  extension <%= type.name %> : ConcreteModel {
      static let meowCollection = Meow.database["<%= type.name.lowercased() %>"]

      static func find(matching closure: ((VirtualInstance) -> (Query))) throws -> Cursor<<%= type.name %>> {
          let query = closure(VirtualInstance())
          return try self.find(matching: query)
      }

      static func findOne(matching closure: ((VirtualInstance) -> (Query))) throws -> <%= type.name %>? {
          let query = closure(VirtualInstance())
          return try self.findOne(matching: query)
      }

      static func count(matching closure: ((VirtualInstance) -> (Query))) throws -> Int {
          let query = closure(VirtualInstance())
          return try self.count(matching: query)
      }
  }

  <%
    // Makes this model initializable by a String representing an ObjectId
  %>
  extension <%= type.name %> : StringInitializable {
    public convenience init?(from string: String) throws {
      guard let document = try <%= type.name %>.meowCollection.findOne(matching: "_id" == (try ObjectId(string))) else {
        return nil
      }

      try self.init(fromDocument: document)
    }
  }

  <%
    // Makes this model ValueConvertible so that it can be expressed as ExtendedJSON
  %>
  extension <%= type.name %> : ValueConvertible {
    public func makeBSONPrimitive() -> BSONPrimitive {
      return self.meowSerialize()
    }
  }

  extension <%= type.name %> : ResponseRepresentable {
    public func makeResponse() -> Response {
      return self.makeExtendedJSON().makeResponse()
    }
  }
<% } %>








<%
  // Adds helpers for Vapor's Droplet
  // Generates routes based on your sourcery comments in models
%>
extension Droplet {
  public func start(_ mongoURL: String) throws -> Never {
    let meow = try Meow.init(mongoURL)

    <% for type in (types.based["Model"] ?? []) { %>
      <% for method in type.methods where method.accessLevel == "public" || method.accessLevel == "internal" && method.annotations["api"] != nil { %>
        <% if method.isStatic { %>
          self.<%= (method.annotations["api"] as? String ?? "").lowercased() %>("<%= type.name.lowercased() %>s", "<%= method.annotations["pathSuffix"] as? String ?? method.shortName %>") { request in
        <% } else { %>
          self.<%= (method.annotations["api"] as? String ?? "").lowercased() %>("<%= type.name.lowercased() %>s", <%= type.name %>.self, "<%= method.annotations["pathSuffix"] as? String ?? method.shortName %>") { request, model in
        <% } %>

        <% if (method.annotations["data"] as? String ?? "").lowercased() == "query" || (method.annotations["data"] as? String ?? "").lowercased() == "json" { %>
          <% if (method.annotations["data"] as? String ?? "").lowercased() == "query" { %>
            guard let query = request.query, case .object(let parameters) = query else {
                return Response(status: .badRequest)
            }
          <% } else { %>
            guard let json = request.json?.node, case .object(let parameters) = json else {
                return Response(status: .badRequest)
            }
          <% } %>

          <% for parameter in method.parameters { %>
            <% if parameter.typeName.isOptional {%>
              <% if parameter.typeName.unwrappedTypeName == "String" { %>
                let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.string
              <% } else if parameter.typeName.unwrappedTypeName == "Int" { %>
                let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.int
              <% } else if parameter.typeName.unwrappedTypeName == "Bool" { %>
                let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.bool
              <% } else if parameter.typeName.unwrappedTypeName == "Float" { %>
                let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.float
              <% } else if parameter.typeName.unwrappedTypeName == "Double" { %>
                let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.double
              <% } else if parameter.typeName.unwrappedTypeName == "ObjectId" { %>
                let <%= parameter.name %> = try? ObjectId(parameters["<%= parameter.name %>"]?.string ?? "")
              <% } else { %>
                return Response(status: .internalServerError)
              <% } %>

            <% } else { %>

              <% if parameter.typeName.unwrappedTypeName == "String" { %>
                guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.string else {
                  return Response(status: .badRequest)
                }
              <% } else if parameter.typeName.unwrappedTypeName == "Int" { %>
                guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.int else {
                  return Response(status: .badRequest)
                }
              <% } else if parameter.typeName.unwrappedTypeName == "Bool" { %>
                guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.bool else {
                  return Response(status: .badRequest)
                }
              <% } else if parameter.typeName.unwrappedTypeName == "Float" { %>
                guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.float else {
                  return Response(status: .badRequest)
                }
              <% } else if parameter.typeName.unwrappedTypeName == "Double" { %>
                guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.double else {
                  return Response(status: .badRequest)
                }
              <% } else if parameter.typeName.unwrappedTypeName == "ObjectId" { %>
                guard let <%= parameter.name %>P = parameters["<%= parameter.name %>"]?.string, let <%= parameter.name %> = try ObjectId(<%= parameter.name %>P) else {
                  return Response(status: .badRequest)
                }
              <% } else { %>
                return Response(status: .internalServerError)
              <% } %>
            <% } %>
          <% } %>
        <% } %>

        <% if (method.annotations["data"] as? String ?? "").lowercased() == "form" { %>
          guard let parameters = request.multipart else {
              return Response(status: .badRequest)
          }

          <% for parameter in method.parameters { %>
            <% if parameter.typeName.isOptional {%>
              <% if parameter.typeName.unwrappedTypeName == "String" { %>
              let <%= parameter.name %>: String?
                if case .input(let <%= parameter.name %>P) = parameters["<%= parameter.name %>"] {
                  <%= parameter.name %> = <%= parameter.name %>P
                } else {
                <%= parameter.name %> = nil
                }
              <% } else if parameter.typeName.unwrappedTypeName == "Int" { %>
              guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                return Response(status: .badRequest)
              }

              let <%= parameter.name %> = Int(<%= parameter.name %>P)
              <% } else if parameter.typeName.unwrappedTypeName == "Bool" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }

                let <%= parameter.name %> = (<%= parameter.name %>P.lowercased() == "true" || <%= parameter.name %>P.lowercased() == "1")
              <% } else if parameter.typeName.unwrappedTypeName == "Float" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }

                let <%= parameter.name %> = Float(<%= parameter.name %>P)
              <% } else if parameter.typeName.unwrappedTypeName == "Double" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }

                let <%= parameter.name %> = Double(<%= parameter.name %>P)
              <% } else if parameter.typeName.unwrappedTypeName == "ObjectId" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }

                let <%= parameter.name %> = try? ObjectId(<%= parameter.name %>P)
              <% } else { %>
                return Response(status: .internalServerError)
              <% } %>

            <% } else { %>
              <% if parameter.typeName.unwrappedTypeName == "String" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }
              <% } else if parameter.typeName.unwrappedTypeName == "Int" { %>
              guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                return Response(status: .badRequest)
              }

              let <%= parameter.name %> = Int(<%= parameter.name %>P)
              <% } else if parameter.typeName.unwrappedTypeName == "Bool" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }

                let <%= parameter.name %> = (<%= parameter.name %>P.lowercased() == "true" || <%= parameter.name %>P.lowercased() == "1")
              <% } else if parameter.typeName.unwrappedTypeName == "Float" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }

                let <%= parameter.name %> = Float(<%= parameter.name %>P)
              <% } else if parameter.typeName.unwrappedTypeName == "Double" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }

                let <%= parameter.name %> = Double(<%= parameter.name %>P)
              <% } else if parameter.typeName.unwrappedTypeName == "ObjectId" { %>
                guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
                  return Response(status: .badRequest)
                }

                let <%= parameter.name %> = try ObjectId(<%= parameter.name %>P)
              <% } else { %>
                return Response(status: .internalServerError)
              <% } %>
            <% } %>
          <% } %>
        <% } %>

        <% if method.isStatic { %>
        // TODO: Reverse isVoid when that works
          <% if !method.returnTypeName.isVoid { %> let responseObject = <% } %>try <%= type.name %>.<%= method.shortName %>(
            <% for (index, parameter) in method.parameters.enumerated() { %>
              <%= parameter.name %>: <%= parameter.name %>
              <% if method.parameters.count != index+1 { %>
              ,
              <% } %>
            <% } %>
          )

          <% if method.returnType?.based["Model"] != nil { %>
            <% if method.returnTypeName.isOptional == true { %>
              return try Meow.Helpers.requireValue(responseObject, keyForError: "")
            <% } else { %>
              return responseObject
            <% } %>
          <% } else if method.returnTypeName.name.hasPrefix("Cursor<") { %>
            <% if method.returnTypeName.isOptional == true { %>
              return try Meow.Helpers.requireValue(responseObject, keyForError: "")
            <% } else { %>
              return responseObject
            <% } %>
          <% } else { %>
            return Response(status: .ok)
          <% } %>
        <% } else { %>
        // TODO: Reverse isVoid when that works
          <% if !method.returnTypeName.isVoid { %> let responseObject = <% } %> try model.<%= method.shortName %>(
            <% for (index, parameter) in method.parameters.enumerated() { %>
              <%= parameter.name %>: <%= parameter.name %>
              <% if method.parameters.count != index+1 { %>
              ,
              <% } %>
            <% } %>
          )

            <% if method.returnType?.based["Model"] != nil { %>
              return responseObject
            <% } else if method.returnType?.based["Embeddable"] != nil { %>
              return responseObject
            <% } else if method.returnTypeName.name.hasPrefix("Cursor<") { %>
              return responseObject
            <% } else { %>
              return Response(status: .ok)
            <% } %>
          <% } %>
          }
      <% } %>
    <% } %>
    self.run()
  }
}
